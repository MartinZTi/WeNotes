# 哈希表
什么是哈希表呢？

`在 ` **JDK1.8** ` 之前，哈希表底层采用数组+链表实现`，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，哈希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。

简单的来说，
:::alert-warning
哈希表是由数组+链表+红黑树（JDK1.8 增加了红黑树部分）实现的，如下图所示。
:::
![](_v_images/20200518172557913_4399.png =700x)

![](_v_images/20200518173642444_29180.png =600x)
总而言之，**JDK1.8**引入红黑树大程度优化了HashMap的性能，那么对于我们来讲保证HashSet集合元素的唯一，其实就是根据对象的hashCode和equals方法来决定的。如果我们往集合中存放自定义的对象，那么保证其唯一，就必须复写hashCode和equals方法建立属于当前对象的比较方式。

###### 自定义类型的元素
给HashSet中存放自定义类型元素时，需要重写对象中的`hashCode`和`equals`方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一